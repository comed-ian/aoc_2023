use std::cmp::Ordering;
use utils::read_lines;

#[derive(Clone, Copy, Debug)]
enum Card {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace,
}

impl From<char> for Card {
    fn from(c: char) -> Self {
        match c {
            '2' =>  Card::Two,
            '3' =>  Card::Three,
            '4' =>  Card::Four,
            '5' =>  Card::Five,
            '6' =>  Card::Six,
            '7' =>  Card::Seven,
            '8' =>  Card::Eight,
            '9' =>  Card::Nine,
            'T' =>  Card::Ten,
            'J' =>  Card::Jack,
            'Q' =>  Card::Queen,
            'K' =>  Card::King,
            'A' =>  Card::Ace,
            _ => panic!("Invalid card {c}"),
        }
    }
}

impl Into<u8> for Card {
    fn into(self) -> u8 {
        match self {
            Card::Two   => 2,
            Card::Three => 3,
            Card::Four  => 4,
            Card::Five  => 5,
            Card::Six   => 6,
            Card::Seven => 7,
            Card::Eight => 8,
            Card::Nine  => 9,
            Card::Ten   => 10,
            Card::Jack  => 11,
            Card::Queen => 12,
            Card::King  => 13,
            Card::Ace   => 14,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq)]
enum Outcome {
    HighCard,
    Pair,
    TwoPair,
    ThreeOfAKind,
    FullHouse,
    FourOfAKind,
    FiveOfAKind,
}

impl Into<u8> for Outcome {
    fn into(&self) -> u8 {
        match self {
            Self::HighCard     => 1,
            Self::Pair         => 2,
            Self::TwoPair      => 3,
            Self::ThreeOfAKind => 4,
            Self::FullHouse    => 5,
            Self::FourOfAKind  => 6,
            Self::FiveOfAKind  => 7,
        }
    }
}

impl Ord for Outcome {
    fn cmp(&self, other: &Self) -> Ordering {
        Into::<u8>::into(self).cmp(Into::<u8>::into(&other))
    }
}

impl PartialOrd for Outcome {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for Outcome {
    fn eq(&self, other: &Self) -> bool {
        self == other
    }
}

impl From<&[Card; 5]> for Outcome {
    fn from(&cards: &[Card; 5]) -> Self {
        let mut v = vec![0u8; 13];
        cards.iter().for_each(|x| v[(Into::<u8>::into(*x) - 2) as usize] += 1);
        println!("{:?}", v);
        let max = v.iter().max().unwrap();
        let min = v.iter().min().unwrap();
        let cnt = v.iter().fold(0u8, | c, x | if *x != 0 { c + 1 } else { c });
        println!("{max}");
        println!("{min}");
        println!("{cnt}");
        match max {
            5 => Outcome::FiveOfAKind,
            4 => Outcome::FourOfAKind,
            3 => {
                if *min == 2 { Outcome::FullHouse }
                else { Outcome::ThreeOfAKind }
            },
            2 => if cnt == 3 { Outcome::TwoPair } else { Outcome::Pair }
            1 => Outcome::HighCard,
            _ => panic!("Error processing outcome of {max}"),
        }
    }
}

#[derive(Clone, Copy, Debug)]
struct Hand {
    cards: [Card; 5],
    bid: u64,
    outcome: Outcome,
    rank: u8,
}

impl Hand {
    fn new(s: &str) -> Self {
        let mut split = s.split(" ");
        let hand = split.next().unwrap();
        let bid = split.next().unwrap().parse::<u64>()
                                       .expect("failed to parse bid");
        let mut cards: [Card; 5] = [Card::Two; 5];
        for (i, c) in hand.chars().enumerate() { cards[i] = Card::from(c) }
        let outcome = Outcome::from(&cards);
        Self { cards, bid, outcome, rank: 0 }
    }
    fn is_stronger(&self, other: &Self) -> bool {
        for i in 0..5 {
            let val: u8 = self.cards[i].into();
            let other_val: u8 = other.cards[i].into();
            if val != other_val { return val > other_val }
        }
        return true
    }
}

fn get_winnings(s: &Vec<String>) -> u64 {
    let mut hands: Vec<Hand> = Vec::new();
    s.iter().for_each(|x| hands.push(Hand::new(x.trim())));
    let mut sorted: Vec<Hand> = Vec::new();
    for i in 0..hands.len() {
        let hand = hands[i].clone();
        let mut idx = 0;
        for j in i..sorted.len() {
            loop {
                let cmp = sorted[j].clone();
                if hand.outcome < cmp.outcome { sorted.insert(j, hand.bid) }
            }
        }
    }
    0
}

fn main() {
	let day: String = env!("CARGO_PKG_NAME").to_owned();
	let mut path: String = "src/".to_owned();
    path.push_str(&day);
	path.push_str("/short_input.txt");

	// Part 1
    let lines: Vec<String> = read_lines(&path[..]);
    let mut sum: u64 = 0;
    sum = get_winnings(&lines);
    // assert_eq!(sum, 2164);
	// println!("{day}, part 1other_val: u8 = other.cards[i].into();   ");
    // println!("  the sum of possible game numbers is {sum}");

	// // // Part 2
	// sum = 0;
    // lines.iter().for_each(|x| sum += get_power(x));
    // assert_eq!(sum, 69929);
	// println!("{day}, part 2");
    // println!("  the sum of powers is {sum}");
}
